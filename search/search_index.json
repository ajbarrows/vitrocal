{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VitroCal","text":"<p>Welcome to the repository for the VitroCal project!</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#install-from-source","title":"Install from source","text":"<pre><code>git clone git@github.com:mpmbq2/vitrocal.git\n</code></pre> <p>We recommend creating a virtual environment.</p> <pre><code>cd vitrocal\nmamba env update -f environment.yml\nconda activate vitrocal\npython -m pip install .\n</code></pre>"},{"location":"#example-useage","title":"Example useage","text":"<pre><code>datacatalog = catalog.DataCatalog()\ndf = datacatalog.load('data')\n</code></pre>"},{"location":"api/","title":"Top-level API for VitroCal","text":"<p>Top-level API for VitroCal.</p> <p>This is the file from which you can do:</p> <pre><code>from vitrocal import some_function\n</code></pre> <p>Use it to control the top-level API of your Python data science project.</p>"},{"location":"api/#vitrocal.datasets.catalog.DataCatalog","title":"<code>DataCatalog</code>","text":"<p>               Bases: <code>AbstractCatalog</code></p> <p>Allows easy access to <code>conf/catalog.yaml</code>. Inspired by https://kedro.org.</p> Source code in <code>vitrocal/datasets/catalog.py</code> <pre><code>class DataCatalog(AbstractCatalog):\n    \"\"\"Allows easy access to `conf/catalog.yaml`. Inspired by\n     https://kedro.org. \n     \"\"\"\n    def __init__(self, fpath=\"../../conf/catalog.yaml\"):\n        self.fpath = fpath\n        self.datasets = self.parse_catalog()\n\n    def parse_catalog(self) -&gt; dict:\n        fpath = self.fpath\n        with open (fpath, 'r') as file:\n            catalog = yaml.safe_load(file)\n        return catalog\n\n    def load(self, dataset):\n        _dataset = self.datasets[dataset]\n        module = _get_dataset_type(_dataset)\n        filepath = _dataset['filepath']\n        load_args = _dataset['load_args']\n\n        return module(filepath, load_args).load()\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor","title":"<code>StandardPreprocessor</code>","text":"<p>               Bases: <code>BasePreprocessor</code></p> <p>Preprocessor object class.</p> <p>Attributes:</p> Name Type Description <code>frames_per_second</code> <code>int</code> <p>Image aquisition rate. Defaults to None.</p> <code>filter_frequency</code> <code>float</code> <p>Lowpass filter frequency (Hz). Defaults to None.</p> <code>filter_order</code> <code>int</code> <p>Order passed to scipy.signal.bessel. Defaults to 1.</p> <code>window_size</code> <code>float</code> <p>Size of rolling window to construct baseline values. Defaults to 60.</p> <code>baseline_threshold</code> <code>float</code> <p>Threshold below which to define baseline values (proportion).  Defaults to None.</p> <code>bleach_period</code> <code>float</code> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>class StandardPreprocessor(BasePreprocessor):\n    \"\"\"Preprocessor object class.\n\n    Attributes:\n        frames_per_second (int, optional): Image aquisition rate. Defaults to None.\n        filter_frequency (float, optional): \n            Lowpass filter frequency (Hz). Defaults to None.\n        filter_order (int, optional): \n            Order passed to scipy.signal.bessel. Defaults to 1.\n        window_size (float, optional): \n            Size of rolling window to construct baseline values. Defaults to 60.\n        baseline_threshold (float, optional): \n            Threshold below which to define baseline values (proportion). \n            Defaults to None.\n        bleach_period (float, optional): \n        Initial photobleaching period to be removed (seconds). Defaults to 60.\n\n    \"\"\"\n\n    def __init__(self, \n                 frames_per_second: int=None,\n                 filter_frequency: float=None,\n                 filter_order: int=1,\n                 window_size: float=60,\n                 baseline_threshold: float=None,\n                 bleach_period: float=60,\n        ):\n\n        self.frames_per_second = frames_per_second\n        self.filter_frequency = filter_frequency\n        self.filter_order = filter_order\n        self.window_size = window_size\n        self.baseline_threshold = baseline_threshold\n        self.bleach_period = bleach_period\n\n\n    def preprocess(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Drop frames, filter, baseline, and compute flouresence change.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n        Returns:\n            pd.DataFrame: Flouresence change dataframe with thes same dimensions\n                as input data.\n        \"\"\"\n\n        data = self.drop_frames(data)\n        data = self.filter(data)\n        baseline = self.baseline(data)\n        d_f = self.compute_fluoresence_change(data, baseline)\n\n        return d_f\n\n    def drop_frames(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Drop frames for all traces.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n        Returns:\n            pd.DataFrame: Dataframe with initial frames (rows) dropped.\n        \"\"\"\n\n        n_frames = len(data)\n        frame_times = np.arange(n_frames) * 1/self.frames_per_second\n        initial_frames = len(frame_times[frame_times &lt;= self.bleach_period])\n\n        return (data\n                .iloc[initial_frames:]\n                .reset_index(drop=True)\n        )\n\n    def _construct_bessel_filter(self, filter_frequency:float, filter_order:int):\n        \"\"\"Apply scipy.signal.bessel filter.\n\n        See https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bessel.html # noqa\n\n        Args:\n            filter_frequency (float): Critical frequency.\n            filter_order (int): Order of the filter.\n\n        Returns:\n            b,a: Numerator (b) and denominator (a) polynomials.\n        \"\"\"\n        b, a = bessel(filter_order, filter_frequency)\n        return b, a\n\n    def filter(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Apply filter object backward and forward.\n\n        Args:\n            data (pd.DataFrame): ROI x image array.\n\n        Returns:\n            pd.DataFrame: Filtered output in the same shape as `data`.\n        \"\"\"\n\n        if self.filter_frequency is None:\n            print(\"No filter applied.\")\n            return data\n        else:\n            b, a = self._construct_bessel_filter(\n                self.filter_frequency,\n                self.filter_order\n            )\n\n            filtered = filtfilt(b, a, data)\n\n            return pd.DataFrame(filtered)\n\n\n    def baseline(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\" Identify baseline fluoresence using a backward-looking rolling window.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n        Returns:\n            pd.DataFrame: Dataframe with same dimensions as input data.\n        \"\"\"\n        window_frames = int(self.window_size * self.frames_per_second)\n\n        # turn this into a FixedBackwardwindowIndexer by reversing the dataframe\n        indexer = FixedForwardWindowIndexer(window_size=window_frames)\n        rev_data = data.iloc[::-1]\n\n        baseline = (rev_data\n            .rolling(window=indexer, min_periods=1)\n            .apply(np.percentile, kwargs={'q': self.baseline_threshold})\n        )\n        return baseline.iloc[::-1]\n\n    def compute_fluoresence_change(self, data: pd.DataFrame, \n                                   baseline: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Compute changfe in flouresence from baseline.\n\n        `(data - baseline) / baseline * 100`\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) input dataframe.\n            baseline (pd.DataFrame): m (images) x n (trace) baseline dataframe.\n\n        Returns:\n            pd.DataFrame: Dataframe with same dimensions as input data.\n        \"\"\"\n        return (data - baseline) / baseline * 100\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor.baseline","title":"<code>baseline(data)</code>","text":"<p>Identify baseline fluoresence using a backward-looking rolling window.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Dataframe with same dimensions as input data.</p> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>def baseline(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\" Identify baseline fluoresence using a backward-looking rolling window.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n    Returns:\n        pd.DataFrame: Dataframe with same dimensions as input data.\n    \"\"\"\n    window_frames = int(self.window_size * self.frames_per_second)\n\n    # turn this into a FixedBackwardwindowIndexer by reversing the dataframe\n    indexer = FixedForwardWindowIndexer(window_size=window_frames)\n    rev_data = data.iloc[::-1]\n\n    baseline = (rev_data\n        .rolling(window=indexer, min_periods=1)\n        .apply(np.percentile, kwargs={'q': self.baseline_threshold})\n    )\n    return baseline.iloc[::-1]\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor.compute_fluoresence_change","title":"<code>compute_fluoresence_change(data, baseline)</code>","text":"<p>Compute changfe in flouresence from baseline.</p> <p><code>(data - baseline) / baseline * 100</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) input dataframe.</p> required <code>baseline</code> <code>DataFrame</code> <p>m (images) x n (trace) baseline dataframe.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Dataframe with same dimensions as input data.</p> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>def compute_fluoresence_change(self, data: pd.DataFrame, \n                               baseline: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Compute changfe in flouresence from baseline.\n\n    `(data - baseline) / baseline * 100`\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) input dataframe.\n        baseline (pd.DataFrame): m (images) x n (trace) baseline dataframe.\n\n    Returns:\n        pd.DataFrame: Dataframe with same dimensions as input data.\n    \"\"\"\n    return (data - baseline) / baseline * 100\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor.drop_frames","title":"<code>drop_frames(data)</code>","text":"<p>Drop frames for all traces.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Dataframe with initial frames (rows) dropped.</p> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>def drop_frames(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Drop frames for all traces.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n    Returns:\n        pd.DataFrame: Dataframe with initial frames (rows) dropped.\n    \"\"\"\n\n    n_frames = len(data)\n    frame_times = np.arange(n_frames) * 1/self.frames_per_second\n    initial_frames = len(frame_times[frame_times &lt;= self.bleach_period])\n\n    return (data\n            .iloc[initial_frames:]\n            .reset_index(drop=True)\n    )\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor.filter","title":"<code>filter(data)</code>","text":"<p>Apply filter object backward and forward.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>ROI x image array.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Filtered output in the same shape as <code>data</code>.</p> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>def filter(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Apply filter object backward and forward.\n\n    Args:\n        data (pd.DataFrame): ROI x image array.\n\n    Returns:\n        pd.DataFrame: Filtered output in the same shape as `data`.\n    \"\"\"\n\n    if self.filter_frequency is None:\n        print(\"No filter applied.\")\n        return data\n    else:\n        b, a = self._construct_bessel_filter(\n            self.filter_frequency,\n            self.filter_order\n        )\n\n        filtered = filtfilt(b, a, data)\n\n        return pd.DataFrame(filtered)\n</code></pre>"},{"location":"api/#vitrocal.preprocessors.StandardPreprocessor.preprocess","title":"<code>preprocess(data)</code>","text":"<p>Drop frames, filter, baseline, and compute flouresence change.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Flouresence change dataframe with thes same dimensions as input data.</p> Source code in <code>vitrocal/preprocessors.py</code> <pre><code>def preprocess(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Drop frames, filter, baseline, and compute flouresence change.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n    Returns:\n        pd.DataFrame: Flouresence change dataframe with thes same dimensions\n            as input data.\n    \"\"\"\n\n    data = self.drop_frames(data)\n    data = self.filter(data)\n    baseline = self.baseline(data)\n    d_f = self.compute_fluoresence_change(data, baseline)\n\n    return d_f\n</code></pre>"},{"location":"api/#vitrocal.detectors.DerivativeDetector","title":"<code>DerivativeDetector</code>","text":"<p>               Bases: <code>BaseDetector</code></p> <p>Initialize derivative detector object.</p> <p>Attributes:</p> Name Type Description <code>threshold</code> <code>float</code> <p>Minimum threshold (percent) to identify  an event. Defaults to 20.</p> Source code in <code>vitrocal/detectors.py</code> <pre><code>class DerivativeDetector(BaseDetector):\n    \"\"\"Initialize derivative detector object.\n\n    Attributes:\n        threshold (float, optional): Minimum threshold (percent) to identify \n            an event. Defaults to 20.\n    \"\"\"\n\n    def __init__(self,\n                 threshold: float=20):\n        self.threshold = threshold\n\n    def detect(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Compute derivatives and detect threshold crossings.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n        Returns:\n            pd.DataFrame: Indicator (Boolean) dataframe of the same dimensions as\n                input data.\n        \"\"\"\n        derivative = self._compute_derivative(data)\n        return derivative &gt; self.threshold\n\n    def _compute_derivative(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Compute element-wise difference.\n\n        Args:\n            data (pd.DataFrame):  m (images) x n (trace) dataframe.\n\n        Returns:\n            pd.DataFrame: Derivative dataframe.\n        \"\"\"\n\n        return data.diff()\n</code></pre>"},{"location":"api/#vitrocal.detectors.DerivativeDetector.detect","title":"<code>detect(data)</code>","text":"<p>Compute derivatives and detect threshold crossings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Indicator (Boolean) dataframe of the same dimensions as input data.</p> Source code in <code>vitrocal/detectors.py</code> <pre><code>def detect(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Compute derivatives and detect threshold crossings.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n    Returns:\n        pd.DataFrame: Indicator (Boolean) dataframe of the same dimensions as\n            input data.\n    \"\"\"\n    derivative = self._compute_derivative(data)\n    return derivative &gt; self.threshold\n</code></pre>"},{"location":"api/#vitrocal.detectors.StandardExtractor","title":"<code>StandardExtractor</code>","text":"<p>               Bases: <code>BaseExtractor</code></p> <p>Initialize event extractor object.</p> <p>Attributes:</p> Name Type Description <code>window</code> <code>Tuple[int]</code> <p>Backward and forward window in seconds  defining an event.</p> <code>frames_per_second</code> <code>int</code> <p>Image aquisition rate.. Defaults to None.</p> <code>threshold</code> <code>float</code> <p>Minimum percentile to identify an event.  Passed to <code>BaseDetector()</code>. Defaults to 20.</p> Source code in <code>vitrocal/detectors.py</code> <pre><code>class StandardExtractor(BaseExtractor):\n    \"\"\"Initialize event extractor object.\n\n    Attributes:\n        window (Tuple[int]): Backward and forward window in seconds \n            defining an event.\n        frames_per_second (int, optional): Image aquisition rate.. Defaults to None.\n        threshold (float, optional):  Minimum percentile to identify an event. \n            Passed to `BaseDetector()`. Defaults to 20.\n    \"\"\"\n\n    def __init__(self,\n                 window: Tuple[int],\n                 frames_per_second: int=None,\n                 threshold: float=20\n    ):  \n        self.window = window\n        self.frames_per_second = frames_per_second\n        self.threshold = threshold\n\n\n    def detect_and_extract(self, data: pd.DataFrame) -&gt; dict:\n        \"\"\"Compute derivatives and extract events.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n        Returns:\n            dict: Dictionary of events.\n        \"\"\"\n        detector = DerivativeDetector(threshold=self.threshold)\n        detected = detector.detect(data)\n\n        return self.extract(data, detected)\n\n    def extract(self, data: pd.DataFrame, detected: pd.DataFrame) -&gt; dict:\n        \"\"\"Extract events using fixed window.\n\n        Args:\n            data (pd.DataFrame): m (images) x n (trace) dataframe.\n            detected (pd.DataFrame): dataframe of detected events.\n\n        Raises:\n            ValueError: `data` and `detected` must be the of the same dimensions.\n\n        Returns:\n            dict: Extracted events.\n        \"\"\"\n        if data.shape != detected.shape:\n            raise ValueError(\"Data and event dataframes must be the same dimensions.\")\n\n        identified = self._identify_events(detected)\n        window = self._convert_window_to_frames()\n\n        extracted_events = {}\n\n        for column in data.columns:\n\n            event_starts = identified[column]\n            roi = data[column]\n\n            indices = event_starts[event_starts == True].index\n\n            events = []\n            for index in indices:\n\n                min_idx = index - window[0]\n                max_idx = index + window[1]\n\n                start = min_idx if min_idx &gt; 0 else 0\n                stop = max_idx if max_idx &lt; len(roi) else len(roi)\n\n                events.append(roi.loc[start:stop])\n\n            extracted_events[roi.name] = events\n\n        return extracted_events\n\n    def _identify_events(self, detected: pd.DataFrame):\n        \"\"\"Identify events (where derivative = 0).\n\n        Args:\n            detected (pd.DataFrame): Dataframe\n\n        Returns:\n            pd.DataFrame: Dataframe of identified events.\n        \"\"\"\n\n        identified = detected[detected.diff() != 0] # only keep start of event\n        identified[identified == False] = np.NaN # non-events\n\n        return detected\n\n    def _convert_window_to_frames(self) -&gt; Tuple[int, int]:\n        \"\"\"Convert window supplied in FPS to numbers of frames.\n\n        Returns:\n            Tuple[int, int]: Detection window expressed as numbers of frames\n                backward and forward respectively.\n        \"\"\"\n        fps = self.frames_per_second\n        window = tuple(int(w * fps) for w in self.window)\n\n        print((f\"With FPS = {self.frames_per_second}, a window of \"\n               f\"{self.window} seconds captures {window[0]} frame(s) \"\n               f\"before and {window[1]} frame(s) after each event.\"))\n\n        return window\n</code></pre>"},{"location":"api/#vitrocal.detectors.StandardExtractor.detect_and_extract","title":"<code>detect_and_extract(data)</code>","text":"<p>Compute derivatives and extract events.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of events.</p> Source code in <code>vitrocal/detectors.py</code> <pre><code>def detect_and_extract(self, data: pd.DataFrame) -&gt; dict:\n    \"\"\"Compute derivatives and extract events.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n\n    Returns:\n        dict: Dictionary of events.\n    \"\"\"\n    detector = DerivativeDetector(threshold=self.threshold)\n    detected = detector.detect(data)\n\n    return self.extract(data, detected)\n</code></pre>"},{"location":"api/#vitrocal.detectors.StandardExtractor.extract","title":"<code>extract(data, detected)</code>","text":"<p>Extract events using fixed window.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>m (images) x n (trace) dataframe.</p> required <code>detected</code> <code>DataFrame</code> <p>dataframe of detected events.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p><code>data</code> and <code>detected</code> must be the of the same dimensions.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Extracted events.</p> Source code in <code>vitrocal/detectors.py</code> <pre><code>def extract(self, data: pd.DataFrame, detected: pd.DataFrame) -&gt; dict:\n    \"\"\"Extract events using fixed window.\n\n    Args:\n        data (pd.DataFrame): m (images) x n (trace) dataframe.\n        detected (pd.DataFrame): dataframe of detected events.\n\n    Raises:\n        ValueError: `data` and `detected` must be the of the same dimensions.\n\n    Returns:\n        dict: Extracted events.\n    \"\"\"\n    if data.shape != detected.shape:\n        raise ValueError(\"Data and event dataframes must be the same dimensions.\")\n\n    identified = self._identify_events(detected)\n    window = self._convert_window_to_frames()\n\n    extracted_events = {}\n\n    for column in data.columns:\n\n        event_starts = identified[column]\n        roi = data[column]\n\n        indices = event_starts[event_starts == True].index\n\n        events = []\n        for index in indices:\n\n            min_idx = index - window[0]\n            max_idx = index + window[1]\n\n            start = min_idx if min_idx &gt; 0 else 0\n            stop = max_idx if max_idx &lt; len(roi) else len(roi)\n\n            events.append(roi.loc[start:stop])\n\n        extracted_events[roi.name] = events\n\n    return extracted_events\n</code></pre>"},{"location":"api/#vitrocal.analyzers.StandardAnalyzer","title":"<code>StandardAnalyzer</code>","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Initialize analyzer object.</p> <p>Attributes:</p> Name Type Description <code>upper_decay_bound</code> <code>float</code> <p>Proportion of data to denote upper bound. Defaults to 0.8.</p> <code>lower_decay_bound</code> <code>float</code> <p>Proprtion of data to denote lower bound. Defaults to 0.2.</p> Source code in <code>vitrocal/analyzers.py</code> <pre><code>class StandardAnalyzer(BaseAnalyzer):\n    \"\"\"Initialize analyzer object.\n\n    Attributes:\n        upper_decay_bound (float, optional): Proportion of data to denote\n            upper bound. Defaults to 0.8.\n        lower_decay_bound (float, optional): Proprtion of data to denote\n            lower bound. Defaults to 0.2.\n    \"\"\"\n    def __init__(self,\n                 upper_decay_bound: float=0.8,\n                 lower_decay_bound: float=0.2\n    ):\n\n        self.upper_decay_bound = upper_decay_bound\n        self.lower_decay_bound = lower_decay_bound\n\n\n    def analyze(self, events: dict) -&gt; pd.DataFrame:\n        \"\"\"Return dataframe with event counts, peaks, and decay.\n\n        Args:\n            events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n        Returns:\n            pd.DataFrame: Summary dataframe.\n        \"\"\"\n\n        decay = self.find_event_decay(events)\n        results = pd.DataFrame()\n        for roi, values in decay.items():\n            tmp = pd.DataFrame(values)\n            tmp.insert(0, 'roi', roi)\n\n            results = pd.concat([results, tmp])\n\n        return results\n\n    def count_events(self, events: dict) -&gt; dict:\n        \"\"\"Count number of events for each trace.\n\n        Args:\n            events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n        Returns:\n            dict: Counts.\n        \"\"\"\n\n        return {k: len(v) for k, v in events.items()}\n\n    def find_event_peaks(self, events: dict) -&gt; dict:\n        \"\"\"Find peak for each event.\n\n        Args:\n            events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n        Returns:\n            dict: Event peaks.\n        \"\"\"\n\n        return {k: [np.max(ev) for ev in v] for k, v in events.items()}\n\n    def find_event_decay(self, events: dict) -&gt; dict:\n        \"\"\"Find event peaks and decay.\n\n        Args:\n            events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n        Returns:\n            dict: Summary dictionary.\n        \"\"\"\n\n        def _handle_decay_values(x):\n            if len(x) &gt;= 1:\n                bound = x[0]\n            else:\n                bound = np.nan\n            return bound\n\n        summary = {}\n        for roi, sequence in events.items():\n            sequence_summary = []\n            event_count = 1\n            for event in sequence:\n                peak = np.max(event)\n                peak_index = np.argmax(event)\n\n                upper_bound = peak * self.upper_decay_bound\n                lower_bound = peak * self.lower_decay_bound\n\n                upper_bounds = []\n                lower_bounds = []\n\n                for value in np.nditer(event[peak_index:]):\n\n                    if value &lt;= upper_bound and value &gt; lower_bound:\n                        upper_bounds.append(value)\n                    if value &lt;= lower_bound:\n                        lower_bounds.append(value)\n\n                upper = _handle_decay_values(upper_bounds)\n                lower = _handle_decay_values(lower_bounds)\n\n                res = {\n                    'event': event_count,\n                    'peak': peak,\n                    'upper': upper,\n                    'lower': lower,\n                    'decay': upper - lower\n                }\n                event_count += 1\n\n                sequence_summary.append(res)\n            summary[roi] = sequence_summary\n\n        return summary\n</code></pre>"},{"location":"api/#vitrocal.analyzers.StandardAnalyzer.analyze","title":"<code>analyze(events)</code>","text":"<p>Return dataframe with event counts, peaks, and decay.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>dict</code> <p>Detected events from <code>StandardExtractor.detect_and_extract()</code></p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Summary dataframe.</p> Source code in <code>vitrocal/analyzers.py</code> <pre><code>def analyze(self, events: dict) -&gt; pd.DataFrame:\n    \"\"\"Return dataframe with event counts, peaks, and decay.\n\n    Args:\n        events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n    Returns:\n        pd.DataFrame: Summary dataframe.\n    \"\"\"\n\n    decay = self.find_event_decay(events)\n    results = pd.DataFrame()\n    for roi, values in decay.items():\n        tmp = pd.DataFrame(values)\n        tmp.insert(0, 'roi', roi)\n\n        results = pd.concat([results, tmp])\n\n    return results\n</code></pre>"},{"location":"api/#vitrocal.analyzers.StandardAnalyzer.count_events","title":"<code>count_events(events)</code>","text":"<p>Count number of events for each trace.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>dict</code> <p>Detected events from <code>StandardExtractor.detect_and_extract()</code></p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Counts.</p> Source code in <code>vitrocal/analyzers.py</code> <pre><code>def count_events(self, events: dict) -&gt; dict:\n    \"\"\"Count number of events for each trace.\n\n    Args:\n        events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n    Returns:\n        dict: Counts.\n    \"\"\"\n\n    return {k: len(v) for k, v in events.items()}\n</code></pre>"},{"location":"api/#vitrocal.analyzers.StandardAnalyzer.find_event_decay","title":"<code>find_event_decay(events)</code>","text":"<p>Find event peaks and decay.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>dict</code> <p>Detected events from <code>StandardExtractor.detect_and_extract()</code></p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Summary dictionary.</p> Source code in <code>vitrocal/analyzers.py</code> <pre><code>def find_event_decay(self, events: dict) -&gt; dict:\n    \"\"\"Find event peaks and decay.\n\n    Args:\n        events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n    Returns:\n        dict: Summary dictionary.\n    \"\"\"\n\n    def _handle_decay_values(x):\n        if len(x) &gt;= 1:\n            bound = x[0]\n        else:\n            bound = np.nan\n        return bound\n\n    summary = {}\n    for roi, sequence in events.items():\n        sequence_summary = []\n        event_count = 1\n        for event in sequence:\n            peak = np.max(event)\n            peak_index = np.argmax(event)\n\n            upper_bound = peak * self.upper_decay_bound\n            lower_bound = peak * self.lower_decay_bound\n\n            upper_bounds = []\n            lower_bounds = []\n\n            for value in np.nditer(event[peak_index:]):\n\n                if value &lt;= upper_bound and value &gt; lower_bound:\n                    upper_bounds.append(value)\n                if value &lt;= lower_bound:\n                    lower_bounds.append(value)\n\n            upper = _handle_decay_values(upper_bounds)\n            lower = _handle_decay_values(lower_bounds)\n\n            res = {\n                'event': event_count,\n                'peak': peak,\n                'upper': upper,\n                'lower': lower,\n                'decay': upper - lower\n            }\n            event_count += 1\n\n            sequence_summary.append(res)\n        summary[roi] = sequence_summary\n\n    return summary\n</code></pre>"},{"location":"api/#vitrocal.analyzers.StandardAnalyzer.find_event_peaks","title":"<code>find_event_peaks(events)</code>","text":"<p>Find peak for each event.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>dict</code> <p>Detected events from <code>StandardExtractor.detect_and_extract()</code></p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Event peaks.</p> Source code in <code>vitrocal/analyzers.py</code> <pre><code>def find_event_peaks(self, events: dict) -&gt; dict:\n    \"\"\"Find peak for each event.\n\n    Args:\n        events (dict): Detected events from `StandardExtractor.detect_and_extract()`\n\n    Returns:\n        dict: Event peaks.\n    \"\"\"\n\n    return {k: [np.max(ev) for ev in v] for k, v in events.items()}\n</code></pre>"}]}